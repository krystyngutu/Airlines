# -*- coding: utf-8 -*-
"""airlinemodels.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1R7_R1NjFxRocrN5jJ0EZG8LOS9fyBSOZ
"""

# pip install streamlit

import pandas as pd
import numpy as np
import streamlit as st
import plotly.graph_objects as go
import plotly.express as px
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import OneHotEncoder, StandardScaler
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from sklearn.ensemble import RandomForestRegressor
from xgboost import XGBRegressor
from sklearn.metrics import mean_squared_error
import datetime

# ----------------------
# PAGE SETUP
# ----------------------
st.set_page_config(layout="wide")
st.title("Flights from NYC to CH - Analysis & Recommendations")

# ----------------------
# HELPER FUNCTIONS
# ----------------------
def extract_parens_or_keep(val):
    """Extract text from parentheses or keep the original value."""
    if pd.isna(val):
        return val
    import re
    match = re.search(r'\((.*?)\)', val)
    return match.group(1) if match else val.strip()

def classify_aircraft(aircraft):
    """Standardize aircraft types into categories."""
    if pd.isna(aircraft):
        return "Other"
    aircraft = str(aircraft).lower()
    if aircraft.startswith("airbus"):
        return "Airbus"
    elif aircraft.startswith("boeing"):
        return "Boeing"
    elif aircraft.startswith("canadair"):
        return "Canadair"
    elif aircraft.startswith("embraer"):
        return "Embraer"
    else:
        return "Other"

def classify_flight_type(row, nyc_airports, swiss_airports):
    """Label flights as Direct or Connecting based on airports."""
    if row['departureAirportID'] in nyc_airports and row['arrivalAirportID'] in swiss_airports:
        return 'Direct'
    return 'Connecting'

def classify_time(hour):
    """Classify hour into morning, afternoon, or night period."""
    if 20 <= hour or hour < 5:
        return 'night'
    elif 5 <= hour < 12:
        return 'morning'
    else:
        return 'afternoon'

def boeing_score(aircraft):
    """Return a negative score for Boeing aircraft."""
    if pd.isna(aircraft):
        return 0
    aircraft = str(aircraft).lower()
    if "boeing" in aircraft:
        return -100  # Strong negative score for Boeing
    elif "airbus" in aircraft:
        return 10    # Preference for Airbus
    return 0         # Neutral for other aircraft

# ----------------------
# DATA LOADING & PREPROCESSING
# ----------------------
@st.cache_data
def load_and_process_data():
    """Load and preprocess flight data with time and day features."""
    try:
        df = pd.read_csv("all_flights.csv")

        # Convert columns
        df['departureTime'] = pd.to_datetime(df['departureTime'], errors='coerce')
        df['arrivalAirportTime'] = pd.to_datetime(df['arrivalAirportTime'], errors='coerce')
        df['price'] = pd.to_numeric(df['price'], errors='coerce')
        df['durationMinutes'] = pd.to_numeric(df['durationTime'], errors='coerce')
        df['totalDurationMinutes'] = pd.to_numeric(df['totalTripDuration'], errors='coerce')
        df['carbonEmissionsThisFlight'] = pd.to_numeric(df.get('carbonEmissionsThisFlight'), errors='coerce')

        # Extract date features
        df['date'] = df['departureTime'].dt.date
        df['departureWeekday'] = df['departureTime'].dt.day_name()
        df['departureHour'] = df['departureTime'].dt.hour
        df['departurePeriod'] = df['departureHour'].apply(classify_time)
        df['isWeekend'] = df['departureWeekday'].isin(['Saturday', 'Sunday']).astype(int)
        df['dayOfWeek'] = df['departureTime'].dt.dayofweek  # Monday=0, Sunday=6

        # Extract features from extensions if present
        if 'extensions' in df.columns:
            df['extensions'] = df['extensions'].fillna(',')
            split_ext = df['extensions'].str.split(',', n=2, expand=True).apply(lambda col: col.str.strip())
            df['recliningAndLegroom'] = split_ext[0]
            df['wifi'] = split_ext[1]
            df['carbonEmssionsEstimate'] = split_ext[2]

            # Clean wifi status
            df.loc[df['wifi'].str.startswith('Carbon', na=False), 'wifi'] = 'Status Unknown'
            df['hasWifi'] = ~df['wifi'].isin(['Status Unknown', np.nan]).astype(int)

        df['recliningAndLegroom'] = df['recliningAndLegroom'].apply(extract_parens_or_keep)
        df['legroom'] = df['legroom'].fillna(df['recliningAndLegroom'])

        # Try to convert legroom to numeric if possible
        df['legroom_numeric'] = pd.to_numeric(df['legroom'].str.split(' ').str[0], errors='coerce')

        # Derived features
        df['pricePerMinute'] = df['price'] / df['totalDurationMinutes']
        df['carbonDifferencePercent'] = (
            (df['carbonEmissionsThisFlight'] - df['carbonEmissionsThisFlight'].mean()) /
            df['carbonEmissionsThisFlight'].mean() * 100
        )

        # Aircraft classification
        df['airplaneLumped'] = df['airplane'].apply(classify_aircraft)
        df['boeing_preference'] = df['airplane'].apply(boeing_score)

        return df
    except Exception as e:
        st.error(f"Error loading data: {e}")
        return pd.DataFrame()  # Return empty DataFrame if error

# ----------------------
# CONSTANTS
# ----------------------
# Define airline groups
direct_airlines = ['SWISS', 'United', 'Delta']
lufthansa_group = ['Austrian', 'Brussels Airlines', 'Discover Airlines', 'Eurowings', 'Edelweiss Air', 'ITA', 'Air Dolomiti', 'Lufthansa', 'SWISS']
star_alliance = ['Aegean', 'Air Canada', 'Air China', 'Air India', 'Air New Zealand', 'ANA', 'Asiana Airlines', 'Austrian', 'Avianca', 'Brussels Airlines', 'CopaAirlines', 'Croatia Airlines', 'Egyptair', 'Ethiopian Airlines', 'Eva Air', 'LOT Polish Airlines', 'Lufthansa', 'Shenzhen Airlines', 'Singapore Airlines', 'South African Airways', 'SWISS', 'Tap Air Portugal', 'Thai', 'Turkish Airlines', 'United']

# Define airports to include
nyc_airports = ["JFK", "EWR", "LGA"]
swiss_airports = ["ZRH", "GVA", "BSL"]

# Define time periods
time_periods = ['morning', 'afternoon', 'night']
weekdays = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']

# ----------------------
# LOAD DATA
# ----------------------
df = load_and_process_data()

if df.empty:
    st.error("Failed to load data. Please check your CSV file.")
    st.stop()

df.head(3)

# ----------------------
# EDA - TIME AND DAY ANALYSIS
# ----------------------
st.header("1. Time and Day Analysis")

# Create tabs for different analyses
tab1, tab2, tab3 = st.tabs(["Day of Week Analysis", "Time of Day Analysis", "Price Trends"])

with tab1:
    # Day of Week Analysis
    st.subheader("Flights by Day of Week")

    # Count of flights by day of week
    day_counts = df.groupby('departureWeekday')['price'].count().reindex(weekdays)

    # Average price by day of week
    day_prices = df.groupby('departureWeekday')['price'].mean().reindex(weekdays)

    # Create side-by-side charts
    col1, col2 = st.columns(2)

    with col1:
        fig_counts = px.bar(
            x=day_counts.index,
            y=day_counts.values,
            title="Number of Flights by Day of Week",
            labels={'x': 'Day of Week', 'y': 'Number of Flights'}
        )
        st.plotly_chart(fig_counts, use_container_width=True)

    with col2:
        fig_prices = px.bar(
            x=day_prices.index,
            y=day_prices.values,
            title="Average Price by Day of Week",
            labels={'x': 'Day of Week', 'y': 'Average Price (USD)'}
        )
        st.plotly_chart(fig_prices, use_container_width=True)

    # Weekend vs Weekday comparison
    st.subheader("Weekend vs Weekday Comparison")

    weekend_data = df.groupby('isWeekend').agg({
        'price': ['mean', 'median', 'count'],
        'totalDurationMinutes': 'mean',
        'carbonEmissionsThisFlight': 'mean'
    })

    weekend_data.columns = ['Average Price', 'Median Price', 'Flight Count',
                           'Average Duration (min)', 'Average Carbon Emissions (kg)']
    weekend_data.index = ['Weekday', 'Weekend']

    st.dataframe(weekend_data.style.format({
        'Average Price': '${:.2f}',
        'Median Price': '${:.2f}',
        'Flight Count': '{:.0f}',
        'Average Duration (min)': '{:.1f}',
        'Average Carbon Emissions (kg)': '{:.1f}'
    }))

    # Box plot of prices by day
    fig_box = px.box(
        df,
        x='departureWeekday',
        y='price',
        category_orders={'departureWeekday': weekdays},
        title="Price Distribution by Day of Week"
    )
    st.plotly_chart(fig_box, use_container_width=True)

with tab2:
    # Time of Day Analysis
    st.subheader("Flights by Time of Day")

    # Count of flights by hour
    hour_counts = df.groupby('departureHour')['price'].count()

    # Average price by hour
    hour_prices = df.groupby('departureHour')['price'].mean()

    # Create side-by-side charts
    col1, col2 = st.columns(2)

    with col1:
        fig_hour_counts = px.bar(
            x=hour_counts.index,
            y=hour_counts.values,
            title="Number of Flights by Hour of Day",
            labels={'x': 'Hour of Day (24h)', 'y': 'Number of Flights'}
        )
        st.plotly_chart(fig_hour_counts, use_container_width=True)

    with col2:
        fig_hour_prices = px.bar(
            x=hour_prices.index,
            y=hour_prices.values,
            title="Average Price by Hour of Day",
            labels={'x': 'Hour of Day (24h)', 'y': 'Average Price (USD)'}
        )
        st.plotly_chart(fig_hour_prices, use_container_width=True)

    # Time period comparison
    st.subheader("Time Period Comparison (Morning/Afternoon/Night)")

    period_data = df.groupby('departurePeriod').agg({
        'price': ['mean', 'median', 'count'],
        'totalDurationMinutes': 'mean',
        'carbonEmissionsThisFlight': 'mean'
    })

    period_data.columns = ['Average Price', 'Median Price', 'Flight Count',
                          'Average Duration (min)', 'Average Carbon Emissions (kg)']

    st.dataframe(period_data.style.format({
        'Average Price': '${:.2f}',
        'Median Price': '${:.2f}',
        'Flight Count': '{:.0f}',
        'Average Duration (min)': '{:.1f}',
        'Average Carbon Emissions (kg)': '{:.1f}'
    }))

    # Box plot of prices by time period
    fig_period_box = px.box(
        df,
        x='departurePeriod',
        y='price',
        category_orders={'departurePeriod': ['morning', 'afternoon', 'night']},
        title="Price Distribution by Time Period"
    )
    st.plotly_chart(fig_period_box, use_container_width=True)

with tab3:
    # Price trends over time
    st.subheader("Price Trends by Date")

    # Daily average prices
    daily_prices = df.groupby('date')['price'].mean().reset_index()
    daily_prices['date'] = pd.to_datetime(daily_prices['date'])

    fig_trend = px.line(
        daily_prices,
        x='date',
        y='price',
        title="Average Daily Price Trend",
        labels={'date': 'Date', 'price': 'Average Price (USD)'}
    )
    st.plotly_chart(fig_trend, use_container_width=True)

    # Heatmap: Day of Week vs Hour
    st.subheader("Price Heatmap: Day of Week vs Hour")

    # Create pivot table
    pivot_data = df.pivot_table(
        values='price',
        index='departureHour',
        columns='departureWeekday',
        aggfunc='mean'
    )

    # Reorder columns to proper weekday order
    pivot_data = pivot_data.reindex(columns=weekdays)

    fig_heatmap = px.imshow(
        pivot_data,
        labels=dict(x="Day of Week", y="Hour of Day (24h)", color="Average Price"),
        x=pivot_data.columns,
        y=pivot_data.index,
        color_continuous_scale="RdBu_r",
        title="Average Price by Day and Hour"
    )
    st.plotly_chart(fig_heatmap, use_container_width=True)



# ----------------------
# AIRCRAFT ANALYSIS
# ----------------------
st.header("2. Aircraft Analysis")

# Aircraft type distribution
st.subheader("Aircraft Type Distribution")

# Count by aircraft type
aircraft_counts = df['airplaneLumped'].value_counts()

fig_aircraft = px.pie(
    values=aircraft_counts.values,
    names=aircraft_counts.index,
    title="Distribution of Aircraft Types"
)
st.plotly_chart(fig_aircraft, use_container_width=True)

# Price by aircraft type
st.subheader("Price by Aircraft Type")

fig_aircraft_price = px.box(
    df,
    x='airplaneLumped',
    y='price',
    title="Price Distribution by Aircraft Type",
    color='airplaneLumped'
)
st.plotly_chart(fig_aircraft_price, use_container_width=True)

# Aircraft by airline
st.subheader("Aircraft Types by Airline")

# Create a crosstab of airline vs aircraft type
airline_aircraft = pd.crosstab(df['airline'], df['airplaneLumped'])

# Convert to percentages
airline_aircraft_pct = airline_aircraft.div(airline_aircraft.sum(axis=1), axis=0) * 100

fig_airline_aircraft = px.imshow(
    airline_aircraft_pct,
    labels=dict(x="Aircraft Type", y="Airline", color="Percentage"),
    x=airline_aircraft_pct.columns,
    y=airline_aircraft_pct.index,
    color_continuous_scale="Viridis",
    title="Aircraft Types by Airline (%)"
)
st.plotly_chart(fig_airline_aircraft, use_container_width=True)

# ----------------------
# FLIGHT RECOMMENDATION MODEL
# ----------------------
st.header("3. Flight Recommendation Model")

st.write("Let's build a model to predict the best flights for your trip to Switzerland")

# Create target variable (good flight score)
df['good_flight_score'] = (
    -1 * df['price'] +                                   # Lower price is better
    -5 * df['totalDurationMinutes'] +                   # Shorter duration is better
    100 * (df['airplaneLumped'] != 'Boeing').astype(int) + # Non-Boeing aircraft preferred
    50 * df['hasWifi'].fillna(0) +                      # Wi-Fi is good
    -10 * abs(df['carbonDifferencePercent']) +          # Lower carbon emissions are better
    20 * (df['departurePeriod'] == 'morning').astype(int)  # Morning flights preferred
)

# Normalize score to 0-100 range
df['good_flight_score'] = (df['good_flight_score'] - df['good_flight_score'].min()) / (df['good_flight_score'].max() - df['good_flight_score'].min()) * 100

# Define features for the model
features = [
    'departureAirportID', 'arrivalAirportID', 'airline',
    'airplaneLumped', 'legroom_numeric',
    'totalDurationMinutes', 'carbonEmissionsThisFlight',
    'dayOfWeek', 'departureHour', 'hasWifi'
]

# Filter data to keep only rows with all features present
model_data = df.dropna(subset=features + ['good_flight_score'])

# Define categorical and numerical features
categorical_features = ['departureAirportID', 'arrivalAirportID', 'airline', 'airplaneLumped']
numerical_features = ['legroom_numeric', 'totalDurationMinutes', 'carbonEmissionsThisFlight', 'dayOfWeek', 'departureHour', 'hasWifi']

# Feature preprocessing
preprocessor = ColumnTransformer([
    ('cat', OneHotEncoder(handle_unknown='ignore'), categorical_features),
    ('num', StandardScaler(), numerical_features)
])

# Create X and y
X = model_data[features]
y = model_data['good_flight_score']

# Train-test split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Random Forest model
model_pipeline = Pipeline([
    ('preprocessor', preprocessor),
    ('model', RandomForestRegressor(n_estimators=100, random_state=42))
])

# Train the model
model_pipeline.fit(X_train, y_train)

# Evaluate the model
y_pred = model_pipeline.predict(X_test)
rmse = np.sqrt(mean_squared_error(y_test, y_pred))

st.write(f"Model performance (RMSE): {rmse:.2f}")

# Score all flights
df['predicted_score'] = np.nan
model_data_indices = model_data.index
df.loc[model_data_indices, 'predicted_score'] = model_pipeline.predict(X)

# ----------------------
# FLIGHT RECOMMENDATIONS
# ----------------------
st.header("4. Flight Recommendations")

st.write("Based on our analysis, here are the best flights for your trip to Switzerland over the next two months:")

# Generate next two months of dates
today = datetime.datetime.now().date()
next_two_months = [today + datetime.timedelta(days=i) for i in range(60)]

col1, col2, col3 = st.columns(3)
with col1:
    preferred_period = st.selectbox("Preferred Time of Day:", ['Any'] + time_periods)
with col2:
    preferred_day = st.selectbox("Preferred Day of Week:", ['Any'] + weekdays)
with col3:
    avoid_boeing = st.checkbox("Avoid Boeing Aircraft", value=True)

# Filter flights based on preferences
recommended_flights = df.copy()

if preferred_period != 'Any':
    recommended_flights = recommended_flights[recommended_flights['departurePeriod'] == preferred_period]

if preferred_day != 'Any':
    recommended_flights = recommended_flights[recommended_flights['departureWeekday'] == preferred_day]

if avoid_boeing:
    recommended_flights = recommended_flights[recommended_flights['airplaneLumped'] != 'Boeing']

# Sort by predicted score
recommended_flights = recommended_flights.sort_values('predicted_score', ascending=False)

# Display top recommendations
top_recommendations = recommended_flights.head(10)[['departureAirportID', 'arrivalAirportID',
                                                 'airline', 'airplane', 'airplaneLumped',
                                                 'departureTime', 'departureWeekday', 'departurePeriod',
                                                 'price', 'totalDurationMinutes', 'predicted_score']]

st.dataframe(top_recommendations.style.format({
    'price': '${:.2f}',
    'totalDurationMinutes': '{:.0f}',
    'predicted_score': '{:.1f}'
}))

# ----------------------
# FINAL RECOMMENDATIONS
# ----------------------
st.header("5. Summary of Findings")

st.write("Based on our analysis, here are the key recommendations for your trip to Switzerland:")

# Get best airport combinations
airport_combos = recommended_flights.groupby(['departureAirportID', 'arrivalAirportID'])['predicted_score'].mean().sort_values(ascending=False)
best_departure = airport_combos.index[0][0]
best_arrival = airport_combos.index[0][1]

# Get best airline
best_airline = recommended_flights.groupby('airline')['predicted_score'].mean().sort_values(ascending=False).index[0]

# Get best day and time
best_day = recommended_flights.groupby('departureWeekday')['predicted_score'].mean().sort_values(ascending=False).index[0]
best_time = recommended_flights.groupby('departurePeriod')['predicted_score'].mean().sort_values(ascending=False).index[0]

# Get best aircraft type (excluding Boeing)
non_boeing = recommended_flights[recommended_flights['airplaneLumped'] != 'Boeing']
best_aircraft = non_boeing.groupby('airplaneLumped')['predicted_score'].mean().sort_values(ascending=False).index[0]

col1, col2 = st.columns(2)

with col1:
    st.markdown(f"""
    ### Best Options for Your Flight

    - **Best Departure Airport:** {best_departure}
    - **Best Arrival Airport:** {best_arrival}
    - **Best Airline:** {best_airline}
    - **Best Aircraft Type:** {best_aircraft}
    - **Best Day of Week:** {best_day}
    - **Best Time of Day:** {best_time}
    """)

with col2:
    # Create summary of price ranges
    price_summary = recommended_flights.groupby(['departureWeekday', 'departurePeriod'])['price'].agg(['mean', 'min', 'max']).reset_index()
    price_summary = price_summary.sort_values('mean')

    st.markdown("### Price Ranges by Day and Time")
    st.dataframe(price_summary.style.format({
        'mean': '${:.2f}',
        'min': '${:.2f}',
        'max': '${:.2f}'
    }))

st.markdown("""
### Final Recommendation

Based on our analysis, we recommend booking a flight with the following characteristics:
""")

# Get the single best flight recommendation
best_flight = recommended_flights.iloc[0]

st.markdown(f"""
- **From:** {best_flight['departureAirportID']} to {best_flight['arrivalAirportID']}
- **Airline:** {best_flight['airline']}
- **Aircraft:** {best_flight['airplane']}
- **Day of Week:** {best_flight['departureWeekday']}
- **Time of Day:** {best_flight['departurePeriod']}
- **Expected Price:** ${best_flight['price']:.2f}
- **Duration:** {best_flight['totalDurationMinutes']:.0f} minutes
""")

st.markdown("""
### Tips for Booking

1. Book flights that depart on a weekday morning for the best combination of price and convenience
2. Avoid Boeing aircraft as requested
3. Consider flights with SWISS or Lufthansa Group airlines, which primarily use Airbus aircraft
4. JFK typically offers more direct flights to Switzerland than other NYC airports
5. Zurich (ZRH) is generally the most convenient arrival airport with the most options
""")



